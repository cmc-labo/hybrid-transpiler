#include "codegen.h"
#include <algorithm>
#include <cctype>

namespace hybrid {

std::string RustCodeGenerator::generate(const IR& ir) {
    output_.str("");
    output_.clear();

    // Generate file header
    writeLine("// Auto-generated Rust code from C++ source");
    writeLine("// Generated by Hybrid Transpiler");
    writeLine("");

    // Generate classes/structs
    for (const auto& class_decl : ir.getClasses()) {
        generateClass(class_decl);
        writeLine("");
    }

    // Generate standalone functions
    for (const auto& func : ir.getFunctions()) {
        generateFunction(func);
        writeLine("");
    }

    // Generate global variables (as constants or static)
    for (const auto& var : ir.getGlobalVariables()) {
        generateVariable(var);
    }

    return output_.str();
}

void RustCodeGenerator::generateClass(const ClassDecl& class_decl) {
    // Generate struct definition
    writeLine("pub struct " + sanitizeName(class_decl.name) + " {");
    indent();

    for (const auto& field : class_decl.fields) {
        std::string visibility = "pub "; // Simplified - would need proper access control
        std::string field_name = sanitizeName(field.name);
        std::string field_type = convertType(field.type);

        writeLine(visibility + field_name + ": " + field_type + ",");
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate impl block for methods
    if (!class_decl.methods.empty()) {
        writeLine("impl " + sanitizeName(class_decl.name) + " {");
        indent();

        for (const auto& method : class_decl.methods) {
            generateFunction(method);
            writeLine("");
        }

        dedent();
        writeLine("}");
    }

    // Generate trait implementations for base classes
    if (!class_decl.base_classes.empty()) {
        writeLine("");
        writeLine("// Note: C++ inheritance converted to trait implementation");
        for (const auto& base : class_decl.base_classes) {
            writeLine("// TODO: Implement trait for base class: " + base);
        }
    }
}

void RustCodeGenerator::generateFunction(const Function& func) {
    std::stringstream sig;

    // Constructor becomes 'new' in Rust
    if (func.is_constructor) {
        sig << "pub fn new(";
    } else {
        sig << "pub fn " << sanitizeName(func.name) << "(";
    }

    // Add self parameter for methods
    if (!func.is_static && !func.is_constructor) {
        if (func.is_const) {
            sig << "&self";
        } else {
            sig << "&mut self";
        }

        if (!func.parameters.empty()) {
            sig << ", ";
        }
    }

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << ": " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type
    if (func.is_constructor) {
        sig << " -> Self";
    } else if (func.return_type->kind != TypeKind::Void) {
        sig << " -> " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Function body (simplified - would need proper AST traversal)
    if (!func.body.empty()) {
        writeLine("// TODO: Implement function body");
        writeLine(func.body);
    } else {
        writeLine("todo!()");
    }

    dedent();
    writeLine("}");
}

void RustCodeGenerator::generateVariable(const Variable& var) {
    std::string modifier = var.is_const ? "const" : "static";
    std::string name = sanitizeName(var.name).c_str();
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    std::string type = convertType(var.type);

    std::stringstream line;
    line << modifier << " " << name << ": " << type;

    if (!var.initializer.empty()) {
        line << " = " << var.initializer;
    }

    line << ";";
    writeLine(line.str());
}

std::string RustCodeGenerator::convertType(const std::shared_ptr<Type>& type) {
    if (!type) return "()";

    switch (type->kind) {
        case TypeKind::Void:
            return "()";

        case TypeKind::Bool:
            return "bool";

        case TypeKind::Integer:
            // Map C++ integer types to Rust
            if (type->name == "int" || type->name == "int32_t") return "i32";
            if (type->name == "long" || type->name == "int64_t") return "i64";
            if (type->name == "short" || type->name == "int16_t") return "i16";
            if (type->name == "char" || type->name == "int8_t") return "i8";
            if (type->name == "unsigned int" || type->name == "uint32_t") return "u32";
            if (type->name == "unsigned long" || type->name == "uint64_t") return "u64";
            if (type->name == "unsigned short" || type->name == "uint16_t") return "u16";
            if (type->name == "unsigned char" || type->name == "uint8_t") return "u8";
            if (type->name == "size_t") return "usize";
            return "i32"; // default

        case TypeKind::Float:
            if (type->name == "float") return "f32";
            if (type->name == "double") return "f64";
            return "f64"; // default

        case TypeKind::Pointer:
            return convertSmartPointer(type);

        case TypeKind::Reference:
            if (type->is_const) {
                return "&" + convertType(type->element_type);
            } else {
                return "&mut " + convertType(type->element_type);
            }

        case TypeKind::Array:
            return "[" + convertType(type->element_type) + "; " +
                   std::to_string(type->size_bytes / type->element_type->size_bytes) + "]";

        case TypeKind::Struct:
        case TypeKind::Class:
            return sanitizeName(type->name);

        default:
            return "/* Unknown type: " + type->name + " */";
    }
}

std::string RustCodeGenerator::convertSmartPointer(const std::shared_ptr<Type>& type) {
    // Check if this is a smart pointer pattern
    if (type->name.find("unique_ptr") != std::string::npos) {
        return "Box<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("shared_ptr") != std::string::npos) {
        return "Rc<" + convertType(type->element_type) + ">";
    }
    if (type->name.find("weak_ptr") != std::string::npos) {
        return "Weak<" + convertType(type->element_type) + ">";
    }

    // Raw pointer - use unsafe raw pointer in Rust
    if (type->is_const) {
        return "*const " + convertType(type->element_type);
    } else {
        return "*mut " + convertType(type->element_type);
    }
}

std::string RustCodeGenerator::sanitizeName(const std::string& name) {
    // Convert C++ naming conventions to Rust snake_case
    std::string result;
    bool prev_upper = false;

    for (size_t i = 0; i < name.size(); ++i) {
        char c = name[i];

        if (std::isupper(c) && i > 0 && !prev_upper) {
            result += '_';
            result += std::tolower(c);
            prev_upper = true;
        } else {
            result += std::tolower(c);
            prev_upper = std::isupper(c);
        }
    }

    // Handle Rust keywords
    static const std::vector<std::string> keywords = {
        "as", "break", "const", "continue", "crate", "else", "enum", "extern",
        "false", "fn", "for", "if", "impl", "in", "let", "loop", "match",
        "mod", "move", "mut", "pub", "ref", "return", "self", "Self",
        "static", "struct", "super", "trait", "true", "type", "unsafe",
        "use", "where", "while"
    };

    if (std::find(keywords.begin(), keywords.end(), result) != keywords.end()) {
        result = "r#" + result;
    }

    return result;
}

} // namespace hybrid
