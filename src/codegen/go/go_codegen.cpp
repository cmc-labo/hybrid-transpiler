#include "codegen.h"
#include <algorithm>
#include <cctype>

namespace hybrid {

std::string GoCodeGenerator::generate(const IR& ir) {
    output_.str("");
    output_.clear();

    // Generate file header
    writeLine("// Auto-generated Go code from C++ source");
    writeLine("// Generated by Hybrid Transpiler");
    writeLine("");
    writeLine("package main");
    writeLine("");

    // Generate imports if needed
    bool needs_imports = false;
    for (const auto& class_decl : ir.getClasses()) {
        for (const auto& field : class_decl.fields) {
            if (field.type->name.find("sync") != std::string::npos) {
                needs_imports = true;
                break;
            }
        }
    }

    if (needs_imports) {
        writeLine("import (");
        indent();
        writeLine("\"sync\"");
        dedent();
        writeLine(")");
        writeLine("");
    }

    // Generate classes/structs
    for (const auto& class_decl : ir.getClasses()) {
        generateClass(class_decl);
        writeLine("");
    }

    // Generate standalone functions
    for (const auto& func : ir.getFunctions()) {
        generateFunction(func);
        writeLine("");
    }

    // Generate global variables
    for (const auto& var : ir.getGlobalVariables()) {
        generateVariable(var);
    }

    return output_.str();
}

void GoCodeGenerator::generateClass(const ClassDecl& class_decl) {
    // Generate struct definition
    std::string struct_name = capitalize(sanitizeName(class_decl.name));
    writeLine("type " + struct_name + " struct {");
    indent();

    for (const auto& field : class_decl.fields) {
        std::string field_name = capitalize(sanitizeName(field.name));
        std::string field_type = convertType(field.type);

        writeLine(field_name + " " + field_type);
    }

    dedent();
    writeLine("}");
    writeLine("");

    // Generate constructor function
    if (!class_decl.methods.empty()) {
        // Find constructor or generate New function
        bool has_constructor = false;
        for (const auto& method : class_decl.methods) {
            if (method.is_constructor) {
                has_constructor = true;

                std::stringstream sig;
                sig << "func New" << struct_name << "(";

                for (size_t i = 0; i < method.parameters.size(); ++i) {
                    const auto& param = method.parameters[i];
                    sig << sanitizeName(param.name) << " " << convertType(param.type);

                    if (i < method.parameters.size() - 1) {
                        sig << ", ";
                    }
                }

                sig << ") *" << struct_name << " {";
                writeLine(sig.str());
                indent();
                writeLine("return &" + struct_name + "{");
                indent();

                // Initialize fields
                for (const auto& field : class_decl.fields) {
                    std::string field_name = capitalize(sanitizeName(field.name));
                    writeLine(field_name + ": " + field_name + ",");
                }

                dedent();
                writeLine("}");
                dedent();
                writeLine("}");
                writeLine("");
                break;
            }
        }

        // Generate methods
        for (const auto& method : class_decl.methods) {
            if (!method.is_constructor && !method.is_destructor) {
                generateFunction(method, struct_name);
                writeLine("");
            }
        }
    }

    // Note about inheritance
    if (!class_decl.base_classes.empty()) {
        writeLine("// Note: C++ inheritance converted to interface embedding");
        for (const auto& base : class_decl.base_classes) {
            writeLine("// TODO: Implement interface for base class: " + base);
        }
        writeLine("");
    }
}

void GoCodeGenerator::generateFunction(const Function& func, const std::string& receiver_type) {
    std::stringstream sig;

    sig << "func ";

    // Add receiver for methods
    if (!receiver_type.empty()) {
        std::string receiver_name = "this";
        if (func.is_const) {
            sig << "(" << receiver_name << " *" << receiver_type << ") ";
        } else {
            sig << "(" << receiver_name << " *" << receiver_type << ") ";
        }
    }

    // Function name
    std::string func_name = capitalize(sanitizeName(func.name));
    sig << func_name << "(";

    // Add parameters
    for (size_t i = 0; i < func.parameters.size(); ++i) {
        const auto& param = func.parameters[i];
        sig << sanitizeName(param.name) << " " << convertType(param.type);

        if (i < func.parameters.size() - 1) {
            sig << ", ";
        }
    }

    sig << ")";

    // Return type
    if (func.return_type->kind != TypeKind::Void) {
        sig << " " << convertType(func.return_type);
    }

    writeLine(sig.str() + " {");
    indent();

    // Function body (simplified)
    if (!func.body.empty()) {
        writeLine("// TODO: Implement function body");
        writeLine(func.body);
    } else {
        writeLine("panic(\"not implemented\")");
    }

    dedent();
    writeLine("}");
}

void GoCodeGenerator::generateVariable(const Variable& var) {
    std::string var_name = capitalize(sanitizeName(var.name));
    std::string var_type = convertType(var.type);

    std::stringstream line;
    line << "var " << var_name << " " << var_type;

    if (!var.initializer.empty()) {
        line << " = " << var.initializer;
    }

    writeLine(line.str());
}

std::string GoCodeGenerator::convertType(const std::shared_ptr<Type>& type) {
    if (!type) return "interface{}";

    switch (type->kind) {
        case TypeKind::Void:
            return ""; // Go doesn't have void, just no return type

        case TypeKind::Bool:
            return "bool";

        case TypeKind::Integer:
            // Map C++ integer types to Go
            if (type->name == "int" || type->name == "int32_t") return "int32";
            if (type->name == "long" || type->name == "int64_t") return "int64";
            if (type->name == "short" || type->name == "int16_t") return "int16";
            if (type->name == "char" || type->name == "int8_t") return "int8";
            if (type->name == "unsigned int" || type->name == "uint32_t") return "uint32";
            if (type->name == "unsigned long" || type->name == "uint64_t") return "uint64";
            if (type->name == "unsigned short" || type->name == "uint16_t") return "uint16";
            if (type->name == "unsigned char" || type->name == "uint8_t") return "uint8";
            if (type->name == "size_t") return "uint";
            return "int32"; // default

        case TypeKind::Float:
            if (type->name == "float") return "float32";
            if (type->name == "double") return "float64";
            return "float64"; // default

        case TypeKind::Pointer:
            // Smart pointers become slices or direct values in Go
            if (type->name.find("unique_ptr") != std::string::npos) {
                return "*" + convertType(type->element_type);
            }
            if (type->name.find("shared_ptr") != std::string::npos) {
                return "*" + convertType(type->element_type);
            }
            // Array pointer becomes slice
            if (type->element_type && type->element_type->kind == TypeKind::Array) {
                return "[]" + convertType(type->element_type->element_type);
            }
            return "*" + convertType(type->element_type);

        case TypeKind::Reference:
            // References become pointers in Go
            return "*" + convertType(type->element_type);

        case TypeKind::Array:
            return "[]" + convertType(type->element_type);

        case TypeKind::Struct:
        case TypeKind::Class:
            return capitalize(sanitizeName(type->name));

        default:
            return "interface{} /* Unknown type: " + type->name + " */";
    }
}

std::string GoCodeGenerator::sanitizeName(const std::string& name) {
    std::string result = name;

    // Handle Go keywords
    static const std::vector<std::string> keywords = {
        "break", "case", "chan", "const", "continue", "default", "defer",
        "else", "fallthrough", "for", "func", "go", "goto", "if", "import",
        "interface", "map", "package", "range", "return", "select", "struct",
        "switch", "type", "var"
    };

    if (std::find(keywords.begin(), keywords.end(), result) != keywords.end()) {
        result = result + "_";
    }

    return result;
}

std::string GoCodeGenerator::capitalize(const std::string& name) {
    if (name.empty()) return name;

    std::string result = name;
    result[0] = std::toupper(result[0]);
    return result;
}

} // namespace hybrid
