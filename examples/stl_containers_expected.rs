// Auto-generated Rust code from C++ source
// Generated by Hybrid Transpiler
//
// Expected output for stl_containers.cpp

use std::collections::{HashMap, BTreeMap, BTreeSet};

pub struct DataProcessor {
    // Vector -> Vec
    pub numbers: Vec<i32>,
    pub names: Vec<String>,

    // Map -> BTreeMap
    pub scores: BTreeMap<String, i32>,

    // UnorderedMap -> HashMap
    pub id_to_name: HashMap<i32, String>,

    // Set -> BTreeSet
    pub unique_ids: BTreeSet<i32>,

    // String -> String
    pub description: String,

    // Optional -> Option
    pub optional_value: Option<i32>,
}

impl DataProcessor {
    pub fn new() -> Self {
        Self {
            numbers: Vec::new(),
            names: Vec::new(),
            scores: BTreeMap::new(),
            id_to_name: HashMap::new(),
            unique_ids: BTreeSet::new(),
            description: String::from("Data processor"),
            optional_value: None,
        }
    }

    // Vector operations
    pub fn add_number(&mut self, n: i32) {
        self.numbers.push(n);
    }

    pub fn get_number(&self, index: usize) -> i32 {
        if index < self.numbers.len() {
            return self.numbers[index];
        }
        -1
    }

    pub fn get_number_count(&self) -> usize {
        self.numbers.len()
    }

    // Map operations
    pub fn set_score(&mut self, name: &str, score: i32) {
        self.scores.insert(name.to_string(), score);
    }

    pub fn get_score(&self, name: &str) -> i32 {
        *self.scores.get(name).unwrap_or(&0)
    }

    pub fn has_score(&self, name: &str) -> bool {
        self.scores.contains_key(name)
    }

    // UnorderedMap operations
    pub fn register_user(&mut self, id: i32, name: &str) {
        self.id_to_name.insert(id, name.to_string());
    }

    pub fn get_user_name(&self, id: i32) -> String {
        self.id_to_name.get(&id).cloned().unwrap_or_default()
    }

    // Set operations
    pub fn add_unique_id(&mut self, id: i32) {
        self.unique_ids.insert(id);
    }

    pub fn has_unique_id(&self, id: i32) -> bool {
        self.unique_ids.contains(&id)
    }

    pub fn get_unique_id_count(&self) -> usize {
        self.unique_ids.len()
    }

    // Optional operations
    pub fn set_value(&mut self, value: i32) {
        self.optional_value = Some(value);
    }

    pub fn clear_value(&mut self) {
        self.optional_value = None;
    }

    pub fn has_value(&self) -> bool {
        self.optional_value.is_some()
    }

    pub fn get_value(&self) -> i32 {
        self.optional_value.unwrap_or(-1)
    }

    // String operations
    pub fn set_description(&mut self, desc: &str) {
        self.description = desc.to_string();
    }

    pub fn get_description(&self) -> String {
        self.description.clone()
    }
}

// Nested containers
pub struct NestedDataStructure {
    // Vector of vectors -> Vec<Vec<T>>
    pub matrix: Vec<Vec<i32>>,

    // Map of vectors -> BTreeMap<K, Vec<V>>
    pub data_sets: BTreeMap<String, Vec<f64>>,

    // Vector of maps -> Vec<BTreeMap<K, V>>
    pub records: Vec<BTreeMap<String, i32>>,
}

impl NestedDataStructure {
    pub fn new() -> Self {
        Self {
            matrix: Vec::new(),
            data_sets: BTreeMap::new(),
            records: Vec::new(),
        }
    }

    pub fn add_row(&mut self, row: Vec<i32>) {
        self.matrix.push(row);
    }

    pub fn add_data_set(&mut self, name: &str, data: Vec<f64>) {
        self.data_sets.insert(name.to_string(), data);
    }

    pub fn add_record(&mut self, record: BTreeMap<String, i32>) {
        self.records.push(record);
    }

    pub fn get_row_count(&self) -> usize {
        self.matrix.len()
    }
}

// Template -> Generic
pub struct Container<T> {
    pub items: Vec<T>,
}

impl<T: Clone> Container<T> {
    pub fn new() -> Self {
        Self { items: Vec::new() }
    }

    pub fn add(&mut self, item: T) {
        self.items.push(item);
    }

    pub fn get(&self, index: usize) -> T {
        self.items[index].clone()
    }

    pub fn size(&self) -> usize {
        self.items.len()
    }

    pub fn empty(&self) -> bool {
        self.items.is_empty()
    }
}

fn main() {
    let mut processor = DataProcessor::new();

    // Add numbers
    processor.add_number(1);
    processor.add_number(2);
    processor.add_number(3);

    // Set scores
    processor.set_score("Alice", 95);
    processor.set_score("Bob", 87);

    // Register users
    processor.register_user(1, "Alice");
    processor.register_user(2, "Bob");

    // Add unique IDs
    processor.add_unique_id(100);
    processor.add_unique_id(200);
    processor.add_unique_id(100); // Duplicate, won't be added (Set behavior)

    // Optional value
    processor.set_value(42);
}
