// Auto-generated Go code from C++ source
// Generated by Hybrid Transpiler
//
// Multithreading Examples - Expected Go Output

package main

import (
	"sync"
	"sync/atomic"
)

/**
 * Example 1: Basic thread creation and joining
 */
type SimpleThreadExample struct {
	Data  int32
	Mutex sync.Mutex
}

func NewSimpleThreadExample() *SimpleThreadExample {
	return &SimpleThreadExample{
		Data: 0,
	}
}

func (this *SimpleThreadExample) WorkerFunction(value int32) {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()
	this.Data += value
}

func (this *SimpleThreadExample) RunThreads() {
	var wg sync.WaitGroup

	// Goroutine 1
	wg.Add(1)
	go func() {
		defer wg.Done()
		this.WorkerFunction(10)
	}()

	// Goroutine 2
	wg.Add(1)
	go func() {
		defer wg.Done()
		this.WorkerFunction(20)
	}()

	// Wait for all goroutines to complete
	wg.Wait()
}

/**
 * Example 2: Thread-safe counter with mutex
 */
type ThreadSafeCounter struct {
	Count int32
	Mutex sync.Mutex
}

func NewThreadSafeCounter() *ThreadSafeCounter {
	return &ThreadSafeCounter{
		Count: 0,
	}
}

func (this *ThreadSafeCounter) Increment() {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()
	this.Count++
}

func (this *ThreadSafeCounter) Decrement() {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()
	this.Count--
}

func (this *ThreadSafeCounter) GetValue() int32 {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()
	return this.Count
}

/**
 * Example 3: Atomic operations
 */
type AtomicCounter struct {
	Count atomic.Int32
}

func NewAtomicCounter() *AtomicCounter {
	return &AtomicCounter{}
}

func (this *AtomicCounter) Increment() {
	this.Count.Add(1)
}

func (this *AtomicCounter) Decrement() {
	this.Count.Add(-1)
}

func (this *AtomicCounter) GetValue() int32 {
	return this.Count.Load()
}

/**
 * Example 4: Producer-Consumer with condition variable
 */
type ProducerConsumer struct {
	Buffer        []int32
	Mutex         sync.Mutex
	Cv            *sync.Cond
	MaxBufferSize int
	Done          atomic.Bool
}

func NewProducerConsumer() *ProducerConsumer {
	pc := &ProducerConsumer{
		Buffer:        make([]int32, 0),
		MaxBufferSize: 10,
	}
	pc.Cv = sync.NewCond(&pc.Mutex)
	return pc
}

func (this *ProducerConsumer) Produce(value int32) {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()

	// Wait until buffer has space
	for len(this.Buffer) >= this.MaxBufferSize {
		this.Cv.Wait()
	}

	this.Buffer = append(this.Buffer, value)
	this.Cv.Signal()
}

func (this *ProducerConsumer) Consume() int32 {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()

	// Wait until buffer has data
	for len(this.Buffer) == 0 && !this.Done.Load() {
		this.Cv.Wait()
	}

	if len(this.Buffer) == 0 {
		return -1 // No more data
	}

	value := this.Buffer[len(this.Buffer)-1]
	this.Buffer = this.Buffer[:len(this.Buffer)-1]
	this.Cv.Signal()

	return value
}

func (this *ProducerConsumer) Finish() {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()

	this.Done.Store(true)
	this.Cv.Broadcast()
}

/**
 * Example 5: Shared data with reader-writer lock
 */
type SharedData struct {
	Data  int32
	Mutex sync.RWMutex
}

func NewSharedData() *SharedData {
	return &SharedData{
		Data: 0,
	}
}

// Multiple readers can read simultaneously
func (this *SharedData) Read() int32 {
	this.Mutex.RLock()
	defer this.Mutex.RUnlock()
	return this.Data
}

// Only one writer at a time
func (this *SharedData) Write(value int32) {
	this.Mutex.Lock()
	defer this.Mutex.Unlock()
	this.Data = value
}

/**
 * Example 6: Detached thread
 */
type DetachedThreadExample struct{}

func NewDetachedThreadExample() *DetachedThreadExample {
	return &DetachedThreadExample{}
}

func (this *DetachedThreadExample) BackgroundTask() {
	// Do some work
}

func (this *DetachedThreadExample) LaunchBackgroundTask() {
	// Goroutine runs independently (detached by default)
	go func() {
		this.BackgroundTask()
	}()
}

/**
 * Example 7: Multiple threads with closure
 */
func ParallelComputation() {
	var result atomic.Int32
	const NUM_THREADS = 4

	var wg sync.WaitGroup

	for i := 0; i < NUM_THREADS; i++ {
		wg.Add(1)
		go func(index int32) {
			defer wg.Done()
			// Each goroutine adds its index to result
			result.Add(index)
		}(int32(i))
	}

	// Wait for all goroutines
	wg.Wait()
}

/**
 * Example 8: Thread pool pattern
 */
type ThreadPool struct {
	Workers    []chan bool
	QueueMutex sync.Mutex
	Cv         *sync.Cond
	Stop       atomic.Bool
	Wg         sync.WaitGroup
}

func NewThreadPool(numThreads int) *ThreadPool {
	tp := &ThreadPool{
		Workers: make([]chan bool, numThreads),
	}
	tp.Cv = sync.NewCond(&tp.QueueMutex)

	for i := 0; i < numThreads; i++ {
		tp.Workers[i] = make(chan bool)
		tp.Wg.Add(1)

		go func(stopChan chan bool) {
			defer tp.Wg.Done()

			for {
				tp.QueueMutex.Lock()

				for !tp.Stop.Load() {
					tp.Cv.Wait()
				}

				shouldStop := tp.Stop.Load()
				tp.QueueMutex.Unlock()

				if shouldStop {
					return
				}

				// Process task
			}
		}(tp.Workers[i])
	}

	return tp
}

func (this *ThreadPool) Close() {
	this.QueueMutex.Lock()
	this.Stop.Store(true)
	this.QueueMutex.Unlock()

	this.Cv.Broadcast()

	// Wait for all workers
	this.Wg.Wait()
}
