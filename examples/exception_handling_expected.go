// Auto-generated Go code from C++ exception handling example
// Generated by Hybrid Transpiler

package main

import (
	"errors"
	"fmt"
	"strconv"
)

/**
 * Example 1: Basic try-catch with standard exceptions
 */
type FileReader struct {
	filename string
	isOpen   bool
}

func NewFileReader(name string) *FileReader {
	return &FileReader{
		filename: name,
		isOpen:   false,
	}
}

// Converted from C++ throw to error return
func (this *FileReader) Open() error {
	defer func() {
		if r := recover(); r != nil {
			// Catch clause
			this.isOpen = false
			panic(r) // Re-throw
		}
	}()

	// Try block
	if this.filename == "" {
		return errors.New("filename cannot be empty")
	}

	// Simulate file opening
	this.isOpen = true
	return nil
}

func (this *FileReader) ReadLine(lineNumber int32) (string, error) {
	if lineNumber < 0 {
		return "", errors.New("line number must be positive")
	}

	return "Line content", nil
}

func (this *FileReader) Close() {
	this.isOpen = false
}

/**
 * Example 2: Multiple catch clauses
 */
type DataValidator struct{}

func (this *DataValidator) ValidateAndConvert(data string) int32 {
	defer func() {
		if r := recover(); r != nil {
			// Multiple catch clauses handled in recovery
		}
	}()

	// Try block
	if data == "" {
		return -1 // Handle empty data
	}

	value, err := strconv.ParseInt(data, 10, 32)
	if err != nil {
		return -1 // Handle parse error
	}

	if value < 0 {
		return 0 // Handle range error
	}

	return int32(value)
}

/**
 * Example 3: RAII with exception safety
 * Go uses defer for cleanup
 */
type Resource struct {
	data []int32
	size uint
}

func NewResource(n uint) (*Resource, error) {
	defer func() {
		if r := recover(); r != nil {
			// Handle memory allocation failure
			panic(r)
		}
	}()

	// Try block
	data := make([]int32, n)
	return &Resource{
		data: data,
		size: n,
	}, nil
}

func (this *Resource) At(index uint) (int32, error) {
	if index >= this.size {
		return 0, errors.New("index out of range")
	}
	return this.data[index], nil
}

// Cleanup handled by Go's garbage collector
// No explicit destructor needed

/**
 * Example 4: Custom exception class
 */
type NetworkException struct {
	message string
}

func (e *NetworkException) Error() string {
	return e.message
}

func NewNetworkException(message string) *NetworkException {
	return &NetworkException{message: message}
}

type NetworkClient struct{}

func (this *NetworkClient) Connect(host string) error {
	if host == "" {
		return NewNetworkException("host cannot be empty")
	}

	defer func() {
		if r := recover(); r != nil {
			// Catch NetworkException
		}
	}()

	// Try block
	success := true

	if !success {
		return NewNetworkException("connection failed")
	}
	return nil
}

func (this *NetworkClient) Request(endpoint string) (string, error) {
	defer func() {
		if r := recover(); r != nil {
			// Convert to custom exception
			if err, ok := r.(error); ok {
				panic(NewNetworkException("request failed: " + err.Error()))
			}
		}
	}()

	// Try block
	if endpoint == "" {
		return "", errors.New("endpoint cannot be empty")
	}

	return "Response data", nil
}

/**
 * Example 5: Exception specifications
 */
type Calculator struct{}

// noexcept -> no error return
func (this *Calculator) Add(a, b int32) int32 {
	return a + b
}

// May throw -> error return
func (this *Calculator) Divide(a, b int32) (int32, error) {
	if b == 0 {
		return 0, errors.New("division by zero")
	}
	return a / b, nil
}

// noexcept with internal try-catch -> defer/recover
func (this *Calculator) SafeDivide(a, b float64) float64 {
	defer func() {
		if r := recover(); r != nil {
			// Convert panic to safe default
		}
	}()

	// Try block
	if b == 0.0 {
		return 0.0
	}
	return a / b
}

/**
 * Example 6: Exception propagation chain
 */
type ServiceLayer struct {
	client *NetworkClient
}

func NewServiceLayer() *ServiceLayer {
	return &ServiceLayer{
		client: &NetworkClient{},
	}
}

func (this *ServiceLayer) FetchData(host, endpoint string) (string, error) {
	defer func() {
		if r := recover(); r != nil {
			// Catch network exception
			if err, ok := r.(error); ok {
				panic(errors.New("service error: " + err.Error()))
			}
		}
	}()

	// Try block
	if err := this.client.Connect(host); err != nil {
		return "", err
	}

	response, err := this.client.Request(endpoint)
	if err != nil {
		return "", fmt.Errorf("service error: %w", err)
	}

	return response, nil
}

/**
 * Example 7: Nested try-catch blocks
 */
type TransactionManager struct{}

func (this *TransactionManager) ExecuteTransaction() bool {
	defer func() {
		if r := recover(); r != nil {
			// Outer catch clause
		}
	}()

	// Outer try block
	this.beginTransaction()

	// Inner try-catch
	func() {
		defer func() {
			if r := recover(); r != nil {
				// Inner catch clause
				this.rollbackTransaction()
				panic(r) // Re-throw
			}
		}()

		// Inner try block
		this.performOperation()
		this.commitTransaction()
	}()

	return true
}

func (this *TransactionManager) beginTransaction()   {}
func (this *TransactionManager) performOperation()   {}
func (this *TransactionManager) commitTransaction()  {}
func (this *TransactionManager) rollbackTransaction() {}

/**
 * Example 8: Exception-safe container operations
 */
type SafeVector[T any] struct {
	data []T
}

func (this *SafeVector[T]) PushBackSafe(value T) error {
	defer func() {
		if r := recover(); r != nil {
			// Handle memory allocation failure
			panic(errors.New("cannot add element: out of memory"))
		}
	}()

	// Try block
	this.data = append(this.data, value)
	return nil
}

func (this *SafeVector[T]) AtSafe(index uint) T {
	defer func() {
		if r := recover(); r != nil {
			// Return default value
		}
	}()

	// Try block
	if index >= uint(len(this.data)) {
		var zero T
		return zero
	}
	return this.data[index]
}

func (this *SafeVector[T]) Size() uint {
	return uint(len(this.data))
}

/**
 * Main function
 */
func main() {
	// Example 1: File operations
	{
		reader := NewFileReader("example.txt")
		if err := reader.Open(); err != nil {
			// Handle error
		}
		line, err := reader.ReadLine(0)
		if err != nil {
			// Handle error
		}
		_ = line
		reader.Close()
	}

	// Example 2: Data validation
	validator := &DataValidator{}
	result := validator.ValidateAndConvert("42")
	_ = result

	// Example 3: RAII (Go uses defer and GC)
	{
		res, err := NewResource(1024)
		if err != nil {
			// Handle error
		}
		value, err := res.At(0)
		if err != nil {
			// Handle error
		}
		_ = value
	} // Resource automatically cleaned up by GC

	// Example 4: Custom exceptions
	client := &NetworkClient{}
	if err := client.Connect("example.com"); err != nil {
		// Handle error
	}
	response, err := client.Request("/api/data")
	if err != nil {
		// Handle network error
	}
	_ = response

	// Example 5: Safe operations
	calc := &Calculator{}
	sum := calc.Add(1, 2)
	_ = sum

	quotient, err := calc.Divide(10, 0)
	if err != nil {
		safeResult := calc.SafeDivide(10.0, 0.0)
		_ = safeResult
	}
	_ = quotient

	// Example 6: Service layer
	service := NewServiceLayer()
	data, err := service.FetchData("api.example.com", "/data")
	if err != nil {
		// Handle service error
	}
	_ = data

	// Example 7: Transactions
	tm := &TransactionManager{}
	success := tm.ExecuteTransaction()
	_ = success

	// Example 8: Safe containers
	vec := &SafeVector[int32]{data: make([]int32, 0)}
	if err := vec.PushBackSafe(42); err != nil {
		// Handle error
	}
	val := vec.AtSafe(0)
	_ = val
}
