// Auto-generated Rust code from C++ exception handling example
// Generated by Hybrid Transpiler

use std::error::Error;
use std::fmt;

/**
 * Example 1: Basic try-catch with standard exceptions
 */
pub struct FileReader {
    filename: String,
    is_open: bool,
}

impl FileReader {
    pub fn new(name: String) -> Self {
        Self {
            filename: name,
            is_open: false,
        }
    }

    // Converted from C++ throw to Result
    pub fn open(&mut self) -> Result<(), Box<dyn Error>> {
        (|| -> Result<(), Box<dyn Error>> {
            if self.filename.is_empty() {
                return Err("Filename cannot be empty".into());
            }

            // Simulate file opening
            self.is_open = true;
            Ok(())
        })()
        .or_else(|err| {
            // Catch clause
            self.is_open = false;
            Err(err) // Re-throw
        })
    }

    pub fn read_line(&self, line_number: i32) -> Result<String, Box<dyn Error>> {
        if line_number < 0 {
            return Err("Line number must be positive".into());
        }

        Ok("Line content".to_string())
    }

    pub fn close(&mut self) {
        self.is_open = false;
    }
}

/**
 * Example 2: Multiple catch clauses
 */
pub struct DataValidator {}

impl DataValidator {
    pub fn validate_and_convert(&self, data: &str) -> i32 {
        (|| -> Result<i32, Box<dyn Error>> {
            if data.is_empty() {
                return Err("Data is empty".into());
            }

            let value: i32 = data.parse()
                .map_err(|_| "Parse error")?;

            if value < 0 {
                return Err("Value must be positive".into());
            }

            Ok(value)
        })()
        .unwrap_or_else(|err| {
            // Multiple catch clauses converted to pattern matching
            match err.to_string().as_str() {
                "Data is empty" | "Parse error" => -1,
                "Value must be positive" => 0,
                _ => -99, // Catch-all
            }
        })
    }
}

/**
 * Example 3: RAII with exception safety
 * Rust's ownership automatically handles RAII
 */
pub struct Resource {
    data: Vec<i32>,
}

impl Resource {
    pub fn new(size: usize) -> Result<Self, Box<dyn Error>> {
        let data = vec![0; size];
        Ok(Self { data })
    }

    pub fn at(&mut self, index: usize) -> Result<&mut i32, Box<dyn Error>> {
        self.data.get_mut(index)
            .ok_or_else(|| "Index out of range".into())
    }
}

// Drop trait automatically called (RAII equivalent)
impl Drop for Resource {
    fn drop(&mut self) {
        // Cleanup handled automatically by Vec's Drop
    }
}

/**
 * Example 4: Custom exception class
 */
#[derive(Debug)]
pub struct NetworkException {
    message: String,
}

impl NetworkException {
    pub fn new(message: String) -> Self {
        Self { message }
    }
}

impl fmt::Display for NetworkException {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for NetworkException {}

pub struct NetworkClient {}

impl NetworkClient {
    pub fn connect(&self, host: &str) -> Result<(), Box<dyn Error>> {
        if host.is_empty() {
            return Err(Box::new(NetworkException::new("Host cannot be empty".to_string())));
        }

        (|| -> Result<(), Box<dyn Error>> {
            let success = true;

            if !success {
                return Err(Box::new(NetworkException::new("Connection failed".to_string())));
            }
            Ok(())
        })()
    }

    pub fn request(&self, endpoint: &str) -> Result<String, Box<dyn Error>> {
        (|| -> Result<String, Box<dyn Error>> {
            if endpoint.is_empty() {
                return Err("Endpoint cannot be empty".into());
            }

            Ok("Response data".to_string())
        })()
        .map_err(|e| {
            Box::new(NetworkException::new(
                format!("Request failed: {}", e)
            )) as Box<dyn Error>
        })
    }
}

/**
 * Example 5: Exception specifications
 */
pub struct Calculator {}

impl Calculator {
    // noexcept -> no Result needed
    pub fn add(&self, a: i32, b: i32) -> i32 {
        a + b
    }

    // May throw -> Result type
    pub fn divide(&self, a: i32, b: i32) -> Result<i32, Box<dyn Error>> {
        if b == 0 {
            return Err("Division by zero".into());
        }
        Ok(a / b)
    }

    // noexcept with internal try-catch -> panics converted to Ok
    pub fn safe_divide(&self, a: f64, b: f64) -> f64 {
        (|| -> Result<f64, Box<dyn Error>> {
            if b == 0.0 {
                return Err("Division by zero".into());
            }
            Ok(a / b)
        })()
        .unwrap_or(0.0) // Convert error to safe default
    }
}

/**
 * Example 6: Exception propagation chain
 */
pub struct ServiceLayer {
    client: Box<NetworkClient>,
}

impl ServiceLayer {
    pub fn new() -> Self {
        Self {
            client: Box::new(NetworkClient {}),
        }
    }

    pub fn fetch_data(&self, host: &str, endpoint: &str) -> Result<String, Box<dyn Error>> {
        self.client.connect(host)?;
        self.client.request(endpoint)
            .map_err(|e| {
                format!("Service error: {}", e).into()
            })
    }
}

/**
 * Example 7: Nested try-catch blocks
 */
pub struct TransactionManager {}

impl TransactionManager {
    pub fn execute_transaction(&self) -> bool {
        (|| -> Result<(), Box<dyn Error>> {
            self.begin_transaction();

            // Inner try-catch
            (|| -> Result<(), Box<dyn Error>> {
                self.perform_operation()?;
                self.commit_transaction();
                Ok(())
            })()
            .or_else(|e| {
                self.rollback_transaction();
                Err(e)
            })?;

            Ok(())
        })()
        .is_ok()
    }

    fn begin_transaction(&self) {}
    fn perform_operation(&self) -> Result<(), Box<dyn Error>> { Ok(()) }
    fn commit_transaction(&self) {}
    fn rollback_transaction(&self) {}
}

/**
 * Example 8: Exception-safe container operations
 */
pub struct SafeVector<T> {
    data: Vec<T>,
}

impl<T: Default> SafeVector<T> {
    pub fn push_back_safe(&mut self, value: T) -> Result<(), Box<dyn Error>> {
        self.data.push(value);
        Ok(())
    }

    pub fn at_safe(&self, index: usize) -> T {
        self.data.get(index)
            .cloned()
            .unwrap_or_default()
    }

    pub fn size(&self) -> usize {
        self.data.len()
    }
}

/**
 * Main function
 */
fn main() -> Result<(), Box<dyn Error>> {
    // Example 1: File operations
    {
        let mut reader = FileReader::new("example.txt".to_string());
        reader.open()?;
        let line = reader.read_line(0)?;
        reader.close();
    }

    // Example 2: Data validation
    let validator = DataValidator {};
    let result = validator.validate_and_convert("42");

    // Example 3: RAII
    {
        let mut res = Resource::new(1024)?;
        let value = res.at(0)?;
    } // Resource automatically cleaned up

    // Example 4: Custom exceptions
    let client = NetworkClient {};
    client.connect("example.com")?;
    let response = client.request("/api/data")?;

    // Example 5: Safe operations
    let calc = Calculator {};
    let sum = calc.add(1, 2);
    match calc.divide(10, 0) {
        Ok(quotient) => println!("Result: {}", quotient),
        Err(_) => {
            let safe_result = calc.safe_divide(10.0, 0.0);
            println!("Safe result: {}", safe_result);
        }
    }

    // Example 6: Service layer
    let service = ServiceLayer::new();
    let data = service.fetch_data("api.example.com", "/data")?;

    // Example 7: Transactions
    let tm = TransactionManager {};
    let success = tm.execute_transaction();

    // Example 8: Safe containers
    let mut vec: SafeVector<i32> = SafeVector { data: Vec::new() };
    vec.push_back_safe(42)?;
    let val = vec.at_safe(0);

    Ok(())
}
